#pragma config(Hubs,  S1, HTMotor,  none,     none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     IRseeker,       sensorHiTechnicIRSeeker1200)
#pragma config(Sensor, S3,     USsensor,       sensorSONAR)
#pragma config(Sensor, S4,     lightSensor,    sensorLightActive)
#pragma config(Motor,  mtr_S1_C1_1,     motorRight,    tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     motorLeft,     tmotorTetrix, openLoop, reversed, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define BLUETAPE 35
float encoder;

void turnLeft(float rate ,int speed = 100){
	if (speed > 100)
		speed = 100;

	if (rate > 1)
		rate = 1;

	motor[motorLeft] = speed - speed*rate;
	motor[motorRight] = speed;
}

void turnRight(float rate,int speed = 100){
	if (speed > 100)
		speed = 100;

	if (rate > 1)
		rate = 1;

	motor[motorLeft] = speed;
	motor[motorRight] = speed - speed*rate;

}

void foward(int speed = 100)
{
	motor[motorLeft] = speed;
	motor[motorRight] = speed;
}



bool followWall(int sensorName = USsensor, int maintain, int tooFar)
{
		int distance = SensorValue[sensorName];
		nxtDisplayCenteredTextLine(4, "Sensor Value: %d", SensorValue[sensorName]);


		if(distance < maintain)
		{
			nxtDisplayCenteredTextLine(3, "TURN RIGHT");
			turnRight(0.4, 80);
		}
		else if(distance >= tooFar )
		{
			// We've reached the end of the wall
			return true;
		}
		else if(distance >= maintain)
		{
			nxtDisplayCenteredTextLine(3, "TURN LEFT");
			turnLeft(0.4,80);
		}

		return false;
}

bool findLine(int threshold, int direction, float rate = 0.4, int speed = 20)
{
		nxtDisplayCenteredTextLine(4, "Sensor Value: %d", SensorValue[lightSensor]);
		if(direction < -1)
			direction = -1;
		if(direction > 1)
			direction = 1;
/*
-1 is Left
1 is right
*/
		if(direction == -1)
		{
			turnLeft(rate, speed);

		}

		else if(direction == 1)
		{
			turnRight(rate, speed);

		}
		if( SensorValue[lightSensor] < threshold)
		{
			return true;
		}
		else return false;
}

bool lineFollow(int threshold_line, float rate ,int speed = 20)
{
	nxtDisplayCenteredTextLine(5, "Sensor Value: %d", SensorValue[lightSensor]);
	nxtDisplayCenteredTextLine(6, "%d", encoder);



		if (SensorValue[lightSensor] > threshold_line)
		{
			turnRight(rate,speed);
			wait1Msec(1);
		}
		else
		{
			turnLeft(rate,speed);
			wait1Msec(1);

		}
	return false;
}






task main()
{
	encoder = 0;

	while(SensorValue[USsensor] >= 40)
	{
		foward(60);
	}
	while(!followWall(USsensor, 30, 255)){wait1Msec(10);}
	encoder = ((nMotorEncoder[motorLeft]+nMotorEncoder[motorRight])/2);
	while(!findLine( 30 , 1, 0.8, 20)){wait1Msec(10);}
	while(findLine( 30 , 1, 0.8, 20)){wait1Msec(10);}
	while(!findLine( 30 , 1, 0.8, 20)){wait1Msec(10);}
	while(findLine( 30 , 1, 0.8, 20)){wait1Msec(10);}
	while(!findLine( 30 , -1, 0.8, 20)){wait1Msec(10);}
	int encoder_init = ((nMotorEncoder[motorLeft]+nMotorEncoder[motorRight])/2);
	while(!lineFollow( 30 ,0.6, 50) && encoder < (encoder_init+(6000))){
		wait1Msec(10);
		encoder = ((nMotorEncoder[motorLeft]+nMotorEncoder[motorRight])/2);
	}

}
