#pragma config(Hubs,  S1, HTServo,  none,     none,     none)
#pragma config(Hubs,  S2, HTMotor,  HTMotor,  HTMotor,  none)
#pragma config(Sensor, S3,     HTSMUX,              sensorI2CCustom)
#pragma config(Sensor, S4,     IRCenter,              sensorI2CCustom)
#pragma config(Motor,  mtr_S2_C1_1,     ArmMotor,      tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S2_C1_2,     empty,         tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S2_C2_1,     LeftDrive,     tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S2_C2_2,     RightDrive,    tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S2_C3_1,     Scissor,       tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S2_C3_2,     motorI,        tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C1_1,    Wrist,                tServoStandard)
#pragma config(Servo,  srvo_S1_C1_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S1_C1_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C1_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C1_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C1_6,    RightWrist,           tServoStandard)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                           Autonomous Mode Code Template
//
// This file contains a template for simplified creation of an autonomous program for an Tetrix robot
// competition.
//
// You need to customize two functions with code unique to your specific robot.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

#include "JoystickDriver.c"  //Include file to "handle" the Bluetooth messages.
#include "drivers/hitechnic-sensormux.h"
#include "drivers/hitechnic-irseeker-v2.h"


const tMUXSensor irsensor1 = msensor_S3_3;
const tMUXSensor irsensor2 = msensor_S3_4;

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                    initializeRobot
//
// Prior to the start of autonomous mode, you may want to perform some initialization on your robot.
// Things that might be performed during initialization include:
//   1. Move motors and servos to a preset position.
//   2. Some sensor types take a short while to reach stable values during which time it is best that
//      robot is not moving. For example, gyro sensor needs a few seconds to obtain the background
//      "bias" value.
//
// In many cases, you may not have to add any code to this function and it will remain "empty".
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

void initializeRobot()
{
  // Place code here to sinitialize servos to starting positions.
  // Sensors are automatically configured and setup by ROBOTC. They may need a brief time to stabilize.
	//servoTarget[Wrist] = 255;

  return;
}


/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                         Main Task
//
// The following is the main code for the autonomous robot operation. Customize as appropriate for
// your specific robot.
//
// The types of things you might do during the autonomous phase (for the 2008-9 FTC competition)
// are:
//
//   1. Have the robot follow a line on the game field until it reaches one of the puck storage
//      areas.
//   2. Load pucks into the robot from the storage bin.
//   3. Stop the robot and wait for autonomous phase to end.
//
// This simple template does nothing except play a periodic tone every few seconds.
//
// At the end of the autonomous period, the FMS will autonmatically abort (stop) execution of the program.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

task main()
{

  int count=0;

  int irsearch=1;
  int servoSync=0;
  int dirIR1 = 0;
  int dirIR2 = 0;
	int dcS1_1, dcS2_1, dcS3_1, dcS4_1, dcS5_1 = 0;
	int dcS1_2, dcS2_2, dcS3_2, dcS4_2, dcS5_2 = 0;
	int firstPeg = 1;
	float ooch = 0.15;


	int wristPos = ServoValue[Wrist];
  int rightWristPos = ServoValue[RightWrist];
//	int dirEnh1, strEnh1;
//  int dirEnh2, strEnh2;

  initializeRobot();

  waitForStart(); // Wait for the beginning of autonomous phase.

  ///////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////
  ////                                                   ////
  ////    Add your robot specific autonomous code here.  ////
  ////                                                   ////
  ///////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////
		eraseDisplay();
  	nMotorEncoder[LeftDrive] = 0 ;
  	nMotorEncoder[RightDrive] = 0 ;
  	nMotorEncoder[ArmMotor] = 0 ;


  	 wristPos = ServoValue[Wrist];
		 rightWristPos = ServoValue[RightWrist];


		 	//Move forward one rotation
    	count = 0;
    	motor[RightDrive] = 31;
    	motor[LeftDrive] = 30;
    	while(nMotorEncoder[RightDrive] < (288))
    	{
    		wait1Msec(1);
    		if(count++ > 500){break;}
    	}
			motor[RightDrive] = 0;
			motor[LeftDrive] = 0;
			wait1Msec(100);



    	count = 0;

			//Open the arm

    	motor[ArmMotor] = -30;
    	while (nMotorEncoder[ArmMotor] > -(171*4*9))
    	{


      eraseDisplay();
      nxtDisplayTextLine(1, "%d", nMotorEncoder[ArmMotor]);



   		if(count++ > 900){break;}

   		wait10Msec(1);



			}
			nxtDisplayTextLine(1, "%d", nMotorEncoder[ArmMotor]);

			motor[LeftDrive] = 0;
    	motor[RightDrive] = 0;
			motor[ArmMotor] = 0;

			//End arm open

			//Set wrist position - increase wrist for forward
			servoTarget[Wrist] = 135;
      servoTarget[RightWrist] = 120;



      //Move back the one rotation
      nMotorEncoder[LeftDrive] = 0 ;
  	  nMotorEncoder[RightDrive] = 0 ;
  	  wait1Msec(100);
    	count = 0;
    	motor[RightDrive] = -31;
    	motor[LeftDrive] = -30;
    	while(nMotorEncoder[RightDrive] > (-288))
    	{
    		wait1Msec(1);
    		if(count++ > 500){break;}
    	}
			motor[RightDrive] = 0;
			motor[LeftDrive] = 0;
			wait1Msec(100);




			motor[LeftDrive] = 0;
    	motor[RightDrive] = 0;
			motor[ArmMotor] = 0;
			nMotorEncoder[LeftDrive] = 0 ;
  	  nMotorEncoder[RightDrive] = 0 ;

			PlayTone(440, 15);

			//Drive forward until we see the we need to turn

	    count = 0;
	    irsearch=1;

		if (dcS1_1>30 && dcS2_1>30 && dcS2_2 > 20){
					irsearch=0;
					firstPeg=1;
					PlayTone(880, 15);
					PlayTone(440, 15);
					PlayTone(880, 15);
					PlayTone(440, 15);
				}

			while (irsearch==1){

				dirIR1 = HTIRS2readACDir(irsensor1);
				HTIRS2readAllACStrength(irsensor1, dcS1_1, dcS2_1, dcS3_1, dcS4_1, dcS5_1 );
				//HTIRS2readEnhanced(irsensor1, dirEnh1, strEnh1);

				dirIR2 = HTIRS2readACDir(irsensor2);
				HTIRS2readAllACStrength(irsensor2, dcS1_2, dcS2_2, dcS3_2, dcS4_2, dcS5_2 );
				//HTIRS2readEnhanced(irsensor2, dirEnh2, strEnh2);

				nxtDisplayTextLine(7, "%d,%d,%d,%d,%d", dcS1_2, dcS2_2, dcS3_2, dcS4_2, dcS5_2);
				nxtDisplayTextLine(6, "%d,%d,%d,%d,%d", dcS1_1, dcS2_1, dcS3_1, dcS4_1, dcS5_1);

			  motor[LeftDrive] = 22;
    	  motor[RightDrive] = 21;


				if (dcS1_1==0 && dcS2_1>30 && dcS2_2 > 20){
					irsearch=0;
					break;

				}

				if(count++ > 300){
					motor[LeftDrive] = 0;
    			motor[RightDrive] = 0;
					wait1Msec(40000);
					}
				wait10Msec(1);

			}

			motor[LeftDrive] = 0;
    	motor[RightDrive] = 0;
			//End the 1st forward drive

    	//eraseDisplay();
	    //nxtDisplayTextLine(1, "%d", nMotorEncoder[RightDrive]);
    	//wait1Msec(5000);

			//if we're within the range of the middle peg, drop the arm just a touch.
    	if (nMotorEncoder[RightDrive]>440){
    		firstPeg=0;
    		PlayTone(880, 15);
					PlayTone(440, 15);
					PlayTone(880, 15);
					PlayTone(440, 15);
    	}

    	if (nMotorEncoder[RightDrive]>440 &&  nMotorEncoder[RightDrive]< (1440*2) ){

	    	count = 0;
	    	nMotorEncoder[ArmMotor] = 0;

	    	wait1Msec(500);

	    	motor[ArmMotor] = -10;

	    	while (nMotorEncoder[ArmMotor] > -(3*4*9))
	    	{



	      eraseDisplay();
	      nxtDisplayTextLine(1, "%d", nMotorEncoder[ArmMotor]);



	   		if(count++ > 200){break;}

	   		wait10Msec(1);


				}

				motor[ArmMotor] = 0;



    	}//end encoder count if



    	//back up a little


			nMotorEncoder[LeftDrive] = 0 ;
  	 nMotorEncoder[RightDrive] = 0 ;
  	 wait1Msec(500);

    	motor[LeftDrive] = -22;
    	motor[RightDrive] = -22;

    	count = 0;
    	while (nMotorEncoder[LeftDrive] > (1440 * -0.18))  // wait for motor to reach a specific location
			{

				nxtDisplayTextLine(2, "%d - %d", nMotorEncoder[LeftDrive], nMotorEncoder[RightDrive]);

			  if(count++ > 2000){break;}
				wait1Msec(1);
  	}
  	nxtDisplayTextLine(2, "%d - %d", nMotorEncoder[LeftDrive], nMotorEncoder[RightDrive]);

    	motor[LeftDrive] = 0;
    	motor[RightDrive] = 0;


		//End backing up




		//Turn until readings from sensor3 are equal
    	count = 0;
    	irsearch=1;

    	PlayTone(880, 15);

			while (irsearch==1){

				motor[LeftDrive] = 17;
				motor[RightDrive] = 0;

				dirIR1 = HTIRS2readACDir(IRCenter);
				HTIRS2readAllACStrength(IRCenter, dcS1_1, dcS2_1, dcS3_1, dcS4_1, dcS5_1 );
				//HTIRS2readEnhanced(irsensor1, dirEnh1, strEnh1);

				nxtDisplayTextLine(7, "%d,%d,%d,%d,%d", dcS1_1, dcS2_1, dcS3_1, dcS4_1, dcS5_1);

				if (firstPeg==1){
						dcS2_1 += 5; //Update to overshoot on first peg
				}

				if (dcS3_1 > dcS2_1 && dcS3_1>20 && dcS2_1>20){

					motor[LeftDrive] = 0;
					motor[RightDrive] = 0;
					irsearch=0;
					break;



				}




				if(count++ > 300){
					motor[LeftDrive] = 0;
    			motor[RightDrive] = 0;
					wait1Msec(40000);
					}
				wait10Msec(1);

			}

			motor[LeftDrive] = 0;
    	motor[RightDrive] = 0;


    	//End Turn



    	//Special left peg case

    	if(firstPeg == 1){

    		PlayTone(880, 15);
    	PlayTone(440, 15);
    		PlayTone(880, 15);
    	PlayTone(440, 15);

    	nMotorEncoder[RightDrive] = 0;
    	wait1Msec(500);
    		count = 0;
    	motor[RightDrive] = 30;
    	motor[LeftDrive] = 31;
    	while(nMotorEncoder[RightDrive] < (2000))
    	{
    		wait1Msec(1);
    		if(count++ > 3000){break;}
    	}
			motor[RightDrive] = 0;
			motor[LeftDrive] = 0;
			wait1Msec(1000);
			//IR Seek
				count = 0;
    	irsearch=1;

    	PlayTone(880, 15);

			while (irsearch==1){



				dirIR1 = HTIRS2readACDir(IRCenter);
				HTIRS2readAllACStrength(IRCenter, dcS1_1, dcS2_1, dcS3_1, dcS4_1, dcS5_1 );
				//HTIRS2readEnhanced(irsensor1, dirEnh1, strEnh1);

				nxtDisplayTextLine(7, "%d,%d,%d,%d,%d", dcS1_1, dcS2_1, dcS3_1, dcS4_1, dcS5_1);

				dcS2_1 += 5;

				if (abs(dcS3_1-dcS2_1)<5 && dcS3_1>20 && dcS2_1>20){

					motor[LeftDrive] = 0;
					motor[RightDrive] = 0;
					irsearch=0;
					PlayTone(880, 150);
					PlayTone(440, 150);
					wait1Msec(500);
					break;

				}else if(dcS3_1 > dcS2_1){
					motor[LeftDrive] = 0;
					motor[RightDrive] = 17;
				}else if(dcS3_1 <= dcS2_1){
					motor[LeftDrive] = 17;
					motor[RightDrive] = 0;
				}else{
					PlayTone(1600, 150);
					wait10Msec(50);
				}



				if(count++ > 500){
					motor[LeftDrive] = 0;
    			motor[RightDrive] = 0;
    			PlayTone(880, 150);
    			PlayTone(440, 150);
					wait1Msec(40000);
					}
				wait10Msec(1);

			}

			motor[LeftDrive] = 0;
    	motor[RightDrive] = 0;
    	}





	//Go forward until the IR reads that we're close


    	count = 0;
    	irsearch=1;
    	motor[LeftDrive] = 22;
			motor[RightDrive] = 20;

    	PlayTone(880, 15);
    	PlayTone(440, 15);

			while (irsearch==1){

				dirIR1 = HTIRS2readACDir(irsensor1);
				HTIRS2readAllACStrength(irsensor1, dcS1_1, dcS2_1, dcS3_1, dcS4_1, dcS5_1 );
				//HTIRS2readEnhanced(irsensor1, dirEnh1, strEnh1);

				dirIR2 = HTIRS2readACDir(irsensor2);
				HTIRS2readAllACStrength(irsensor2, dcS1_2, dcS2_2, dcS3_2, dcS4_2, dcS5_2 );
				//HTIRS2readEnhanced(irsensor2, dirEnh2, strEnh2);

				nxtDisplayTextLine(7, "%d,%d,%d,%d,%d", dcS1_2, dcS2_2, dcS3_2, dcS4_2, dcS5_2);
		    nxtDisplayTextLine(6, "%d,%d,%d,%d,%d", dcS1_1, dcS2_1, dcS3_1, dcS4_1, dcS5_1);



				//if (((dcS3_1>20 && dcS3_2>20 && dcS2_2>20 && firstPeg == 0) || (dcS3_1>20 && dcS4_1>20 && dcS3_2>20 && firstPeg == 0)) || (dcS3_1>20 && dcS4_1>20 && dcS3_2>20 && dcS2_2>20 && firstPeg == 1)){
		    if (((dcS3_1>20 && dcS3_2>20 && dcS2_2>20) || (dcS3_1>20 && dcS4_1>20 && dcS3_2>20))){
					motor[LeftDrive] = 0;
    			motor[RightDrive] = 0;
					irsearch=0;
					break;
				}

				if(count++ > 100){
					motor[LeftDrive] = 0;
    			motor[RightDrive] = 0;
					irsearch=0;
					//wait1Msec(40000);
    			break;
					}
				wait10Msec(1);

			}

			motor[LeftDrive] = 0;
    	motor[RightDrive] = 0;
			//End forward until close







    	PlayTone(440, 15);

    	//ooch forward


    		motor[LeftDrive] = 0;
    	motor[RightDrive] = 0;
			motor[ArmMotor] = 0;

			nMotorEncoder[LeftDrive] = 0 ;
  	 nMotorEncoder[RightDrive] = 0 ;
  	 wait1Msec(500);

    	motor[LeftDrive] = 30;
    	motor[RightDrive] = 40;

    	count = 0;
    	if (firstPeg==1){
    		ooch = 0.5;
     }

    	while (nMotorEncoder[LeftDrive] < (1440 * ooch) && nMotorEncoder[RightDrive] < (1440 * ooch) )  // wait for motor to reach a specific location
			{

				nxtDisplayTextLine(2, "%d - %d", nMotorEncoder[LeftDrive], nMotorEncoder[RightDrive]);
				if (count>100){
					PlayTone(440,15);

				}

			  if(count++ > 100){
			  motor[LeftDrive] = 0;
    		motor[RightDrive] = 0;
			  break;
			  }
				wait10Msec(1);
  	}
  	nxtDisplayTextLine(2, "%d - %d", nMotorEncoder[LeftDrive], nMotorEncoder[RightDrive]);


    	motor[LeftDrive] = 0;
    	motor[RightDrive] = 0;


    	//End forward ooching



    	//drop arm



    	    	count = 0;
    	nMotorEncoder[ArmMotor] = 0;

    	wait1Msec(500);

    	motor[ArmMotor] = -15;

    	while (nMotorEncoder[ArmMotor] > -(17*4*9))
    	{



      eraseDisplay();
      nxtDisplayTextLine(1, "%d", nMotorEncoder[ArmMotor]);



   		if(count++ > 200){break;}

   		wait10Msec(1);


			}

			motor[ArmMotor] = 0;

			//back up a little
			nMotorEncoder[LeftDrive] = 0 ;
  	 nMotorEncoder[RightDrive] = 0 ;
  	 wait1Msec(500);

    	motor[LeftDrive] = -22;
    	motor[RightDrive] = -22;

    	count = 0;
    	while (nMotorEncoder[LeftDrive] > (1440 * -0.25))  // wait for motor to reach a specific location
			{

				nxtDisplayTextLine(2, "%d - %d", nMotorEncoder[LeftDrive], nMotorEncoder[RightDrive]);

			  if(count++ > 2000){break;}
				wait1Msec(1);
  	}
  	nxtDisplayTextLine(2, "%d - %d", nMotorEncoder[LeftDrive], nMotorEncoder[RightDrive]);

    	motor[LeftDrive] = 0;
    	motor[RightDrive] = 0;
		//End backing up




			//End arm drop

    		wait1Msec(40000);



}
