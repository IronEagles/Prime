#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTServo,  HTMotor)
#pragma config(Hubs,  S2, HTMotor,  none,     none,     none)
#pragma config(Sensor, S3,     GYRO,           sensorI2CHiTechnicGyro)
#pragma config(Sensor, S4,     irsensor,       sensorHiTechnicIRSeeker1200)
#pragma config(Motor,  mtr_S1_C1_1,     LeftDrive,     tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     RightDrive,    tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     scoreWrist,    tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     carWash,       tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_1,     liftArm,       tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C4_2,     scoreArm,      tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S2_C1_1,     pullUp,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S2_C1_2,     flagSpinner,   tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C3_1,    autoServo,            tServoStandard)
#pragma config(Servo,  srvo_S1_C3_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define BLUETAPE 35
#include "JoystickDriver.c"  //Include file to "handle" the Bluetooth messages.

void initializeRobot()
{
  // Place code here to sinitialize servos to starting positions.
  // Sensors are automatically configured and setup by ROBOTC. They may need a brief time to stabilize.
	//servoTarget[Wrist] = 255;

  nMotorEncoder[RightDrive] = 0;
	nMotorEncoder[LeftDrive] = 0;

  return;
}

#include "drivers/hitechnic-gyro.h"
float currHeading = 0.0;


task heading()
{
	float delTime = 0.0;
	float prevHeading = 0.0;
	float curRate = 0.0;
	HTGYROstartCal(GYRO);
   while (true) {
   	time1[T1] = 0;
    	curRate = HTGYROreadRot(GYRO);
    	if (abs(curRate) > 3) {
      	prevHeading = currHeading;
      	currHeading = prevHeading + (curRate * delTime);
      	if (currHeading > 360) currHeading -= 360;
      	else if (currHeading < 0) currHeading += 360;
    		}
    nxtDisplayTextLine(4, "Curr = %f", currHeading);
   	wait1Msec(5);
    	delTime = ((float)time1[T1]) / 1000;
    	//delTime /= 1000;

	}
}

task main()
{

	initializeRobot();

  waitForStart(); // Wait for the beginning of autonomous phase.

  	StartTask(heading);
  	wait1Msec(1000);

  	//Turn 45 degrees
  	/*motor[LeftDrive] = 80;
	motor[RightDrive] = -30;

	while(true)
	{
		nxtDisplayCenteredTextLine(3, "Heading: %d", currHeading);
		wait1Msec(5);
		if (currHeading > 30.0 && currHeading < 60.0 )
		{
			break;
	  }
	}

	motor[LeftDrive] = 0;
	motor[RightDrive] = 0;*/


	//drive straign until irsensor

	nMotorEncoder[RightDrive] = 0;
	nMotorEncoder[LeftDrive] = 0;

 while(SensorValue[irsensor] < 6)
{
		nxtDisplayCenteredTextLine(3, "IR: %d", SensorValue[irsensor]);
	motor[LeftDrive] = 40;
	motor[RightDrive] = 40;
	wait1Msec(5);
}

	motor[RightDrive] = 0;
	motor[LeftDrive] = 0;
	wait1Msec(500);

	servoTarget[autoServo] = 200;
	wait1Msec(500);
	servoTarget[autoServo] = 255;
	wait1Msec(500);

	//long drive along wall with IR score

	while(nMotorEncoder[RightDrive] < 4*360*4)
	{
		motor[RightDrive] = 40;
		motor[LeftDrive] = 40;
	}

	motor[RightDrive] = 0;
	motor[LeftDrive] = 0;
	currHeading = 0.0;
	wait1Msec(500);

	//turn 90 degrees first

	motor[LeftDrive] = -70;
	motor[RightDrive] = 70;

	while(true)
	{
		nxtDisplayCenteredTextLine(3, "Heading: %d", currHeading);
		wait1Msec(10);
		if (currHeading >= 300.0 && currHeading < 315)
		{
			break;
	  }
	}

	motor[LeftDrive] = 0;
	motor[RightDrive] = 0;
	nMotorEncoder[RightDrive] = 0;
	nMotorEncoder[LeftDrive] = 0;
	wait1Msec(100);

	//drive 2 feet before ramp turn

	while(nMotorEncoder[RightDrive] < 4*360*2)
	{
		motor[RightDrive] = 40;
		motor[LeftDrive] = 40;
	}

	motor[RightDrive] = 0;
	motor[LeftDrive] = 0;
	currHeading = 0.0;
	wait1Msec(100);

	//second 90 degree turn

	motor[LeftDrive] = -70;
	motor[RightDrive] = 70;

	while(true)
	{
		nxtDisplayCenteredTextLine(3, "Heading: %d", currHeading);
		wait1Msec(10);
		if (currHeading >= 240.0 && currHeading < 260)
		{
			break;
	  }
	}

	motor[LeftDrive] = 0;
	motor[RightDrive] = 0;
	nMotorEncoder[RightDrive] = 0;
	nMotorEncoder[LeftDrive] = 0;
	wait1Msec(100);

	//drive onto ramp

	while(nMotorEncoder[RightDrive] < 4*360*4)
	{
		motor[RightDrive] = 70;
		motor[LeftDrive] = 70;
	}

	motor[RightDrive] = 0;
	motor[LeftDrive] = 0;
	currHeading = 0.0;
	wait1Msec(100);


	wait10Msec(2000);



}
