#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTServo,  HTMotor)
#pragma config(Hubs,  S2, HTMotor,  none,     none,     none)
#pragma config(Sensor, S3,     touch,          sensorTouch)
#pragma config(Sensor, S4,     irsensor,       sensorHiTechnicIRSeeker1200)
#pragma config(Motor,  mtr_S1_C1_1,     LeftDrive,     tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     RightDrive,    tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     scoreWrist,    tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     carWash,       tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_1,     liftArm,       tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C4_2,     scoreArm,      tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S2_C1_1,     pullUp,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S2_C1_2,     flagSpinner,   tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C3_1,    autoServo,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define BLUETAPE 35
#include "JoystickDriver.c"  //Include file to "handle" the Bluetooth messages.


void initializeRobot()
{
  // Place code here to sinitialize servos to starting positions.
  // Sensors are automatically configured and setup by ROBOTC. They may need a brief time to stabilize.
	//servoTarget[Wrist] = 255;

  return;
}



//void turnLeft(float rate ,int speed = 100){
//	if (speed > 100)
//		speed = 100;

//	if (rate > 1)
//		rate = 1;

//	motor[motorLeft] = speed - speed*rate;
//	motor[motorRight] = speed;

//}

//void turnRight(float rate,int speed = 100){
//	if (speed > 100)
//		speed = 100;

//	if (rate > 1)
//		rate = 1;

//	motor[motorLeft] = speed;
//	motor[motorRight] = speed - speed*rate;

//}

//void foward(int speed = 100)
//{
//	motor[motorLeft] = speed;
//	motor[motorRight] = speed;
//}



//bool followWall(int sensorName = USsensor, int maintain, int tooFar)
//{
//		int distance = SensorValue[sensorName];
//		nxtDisplayCenteredTextLine(4, "Sensor Value: %d", SensorValue[sensorName]);


//		if(distance < maintain)
//		{
//			nxtDisplayCenteredTextLine(3, "TURN RIGHT");
//			turnRight(0.4, 80);
//		}
//		else if(distance >= tooFar )
//		{
//			// We've reached the end of the wall
//			return true;
//		}
//		else if(distance >= maintain)
//		{
//			nxtDisplayCenteredTextLine(3, "TURN LEFT");
//			turnLeft(0.4,80);
//		}

//		return false;
//}

//bool findLine(int threshold, int direction, float rate = 0.4, int speed = 20)
//{
//		if(direction < -1)
//			direction = -1;
//		if(direction > 1)
//			direction = 1;
///*
//-1 is Left
//1 is right
//*/
//		if(direction == -1)
//		{
//			turnLeft(rate, speed);

//		}

//		else if(direction == 1)
//		{
//			turnRight(rate, speed);

//		}
//		if( SensorValue[USsensor] > threshold)
//			return true;
//		else return false;
//}






task main()
{

	initializeRobot();

  waitForStart(); // Wait for the beginning of autonomous phase.

 while(SensorValue[irsensor] < 5)
{
	motor[LeftDrive] = -40;
	motor[RightDrive] = -40;
	wait1Msec(5);
}

	motor[RightDrive] = 0;
	motor[LeftDrive] = 0;
	wait1Msec(500);

	servoTarget[autoServo] = 0;




}
